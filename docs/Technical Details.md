
# Technical Details

BridgeNet creates a few instances in the ReplicatedStorage root:
	- `MetaRemoteEvent` (RemoteEvent)
		This is how BridgeNet2 handles meta messages (e.g. connecting players)
	- `DataRemoteEvent` (RemoteEvent)
		This is the actual remote that sends data through
	- `IdentifierStorage` (Folder)
		This is the folder that identifiers are passed through- it uses attributes to store them

**Don't touch any of these instances unless you know what you're doing. They can easily break BridgeNet2 if they're even slightly altered.**


### It's worth noting that `Reference` functions (`ReferenceBridge` and `ReferenceIdentifier`) have very different behavior depending on if the caller is the client or the server. For example: `ReferenceIdentifier` can yield on the client, but will never yield on the server.

There are two processes in BridgeNet2: `ServerProcess` and `ClientProcess`. The `ServerProcess` handles communication from the server to the client using the format `{ [identifierName] = { {uniqueMessage}, {otherUniqueMessage} } }`. It is more efficient to use the same bridge for multiple messages, but identifiers can be used to bypass this limitation. The `ClientProcess` handles communication from the client to the server using the format `{ [even] = "identifier", [odd] = {uniqueMessage} }`.

Identifiers in BridgeNet are generated by the server and use a combination of attributes and string packing to create unique numbers. On the client, identifiers can be accessed using `.FromIdentifier()`, but it is safer to use `.ReferenceIdentifier()` as it yields until the identifier is loaded. The server keeps track of the number of identifiers in use and uses this to generate a new identifier when needed.

You can find a lot of general knowledge on how Roblox does networking [here](<https://devforum.roblox.com/t/in-depth-information-about-robloxs-remoteevents-instance-replication-and-physics-replication-w-sources/1847340>)
